/*filename: rootfs.cauthor:   wei-codertime:	  2018-09-15purpose:  rootfs文件系统的相关函数实现*/#include "vfs.h"static struct super_operations rootfs_op = {	.alloc_inode = alloc_inode_rf,	.destroy_inode = destroy_inode_rf,	.dirty_inode = NULL,	.write_inode = NULL,	.read_super = read_super_rf,	.write_super = NULL,};static fs_type_t rootfs_type = {	.name = "rootfs",	.fs_flag = 0,	.mount = rootfs_mount,	.kill_sb = rootfs_kill_sb};static inode_operations rootfs_inode_op = {	.create = create_inode_rf,	.mkdir = mkdir_rf,	.rmdir = rmdir_rf,	.mknod = NULL,	.rename = rename_rf,	.lookup = lookup_rf};	static dentry_t root_dentry = {	.d_inode = NULL;	.d_iname = "/";	.d_mounted = 0;};/*super block的初始化函数，对rootfs来说，就是申请内存，赋初值*/int read_super_rf(sb_t * pSblk){	if(NULL == pSblk)	{		return KER_FAIL;	}	pSblk->s_dev = 0;	pSblk->s_blocksize = 4096;	pSblk->s_files = NULL;	pSblk->s_inodes = NULL;	pSblk->s_magic = ROOTFS_MAGIC_NUM;	pSblk->s_root = NULL;	pSblk->s_op = &rootfs_op;	return KER_SUC;}/*super block的操作函数，用于初始化一个inode对象*/inode_t * alloc_inode_rf(){}/*super block用于释放inode的函数*/bool destroy_inode_rf(u32 inode_no){	inode_t * tmp = find_inode(inode_no);	if(NULL == tmp)	{		logging("[WARN]: this inode number has no found!\r\n");		return false;	}	list_head_del_node(tmp->i_list);	free(tmp);	return true;}/*在内存中申请一个inode对象*/inode_t* new_inode_rf(){	inode_t * inode_rf = kmalloc(sizeof(inode_t));	if(NULL == inode_rf)	{		logging("[ROOTFS] alloc inode failed!\r\n");		return NULL;	}	memset(inode_rf, 0, sizeof(inode_t));	inode_rf->i_rdev = 0;	inode_rf->i_size = 0;	inode_rf->i_atime = 0;	inode_rf->i_ctime = 0;	inode_rf->i_blocks = 4096;	inode_rf->i_blkbits = 0;	inode_rf->i_mode = 0;	inode_rf->i_ino = 0xFFFFFFFF;	inode_rf->i_count = 0;	inode_rf->i_op = &rootfs_inode_op;	inode_rf->i_fop = NULL;	inode_rf->i_mapping = NULL;	return inode_rf;}inode_t* create_inode_rf(inode_t * fNode, dentry_t * pDentry, int flag, void * name){	return NULL;}int mkdir_rf(inode_t * pNode, dentry_t * pDentry, mode_t mode ){	inode_t * new_node = new_inode_rf();}int rmdir_rf(inode_t *, dentry_t *){}int rename_rf(inode_t *, dentry_t *){}dentry_t * lookup_rf(inode_t *, dentry_t *, void *){}dentry_t * rootfs_mount(struct file_system_type * fs_type, int flags, const char * fs_name, void * data){	sb_t * rootfs_sb = (sb_t *)kmalloc(sizeof(sb_t));	if(NULL == rootfs_sb)	{		logging("[FATAL] kmalloc rootfs super block failed!\r\n");		return NULL;	}	struct list_head * tail = getlast_lh(g_sblk->s_list);	if(NULL == tail)	{		g_sblk = rootfs_sb;		g_sblk->s_list->next = NULL;		g_sblk->s_list->prev = NULL;	}	else	{		tail->next = rootfs_sb->s_list;		rootfs_sb->s_list->prev = tail;		rootfs_sb->s_list->next = NULL;	}	if(read_super_rf(rootfs_sb) == KER_FAIL)	{		logging("[ERROR] rootfs:read super block failed!");		return NULL;	}	inode_t *root_node = new_inode_rf();	rootfs_sb->s_root = &root_dentry;	rootfs_sb->s_root->d_inode = root_node;	rootfs_sb->s_root->d_parent = NULL;	rootfs_sb->s_root->d_sb = rootfs_sb;}void * rootfs_kill_sb(sb_t * psblk){	if(list_head_del_node(psblk->s_list))	{		file_t * delfile = (inode_t *)(psblk->s_files);		while(delfile)		{			psblk->s_files = delfile->f_list->next;			free(delfile);		}		inode_t * delnode = (inode_t *)(psblk->s_inodes);		while(delnode)		{			psblk->s_inodes = delnode->i_list->next;			psblk->s_op->destroy_inode(delnode));			delnode = (inode_t *)(psblk->s_inodes);		}		kfree(psblk);	};}void init_rootfs(){	register_filesystem(&rootfs_type);	rootfs_type.mount(&rootfs_type, 0, "rootfs", NULL);	logging("[INFO] init rootfs success!\r\n");	return;}void init_mnt_tree(){	}