/*filename: rootfs.cauthor:   wei-codertime:	  2018-09-15purpose:  rootfs文件系统的相关函数实现*/#include "vfs.h"static struct super_operations rootfs_op = {	.alloc_inode = alloc_inode_rf,	.destroy_inode = destroy_inode_rf,	.dirty_inode = NULL,	.write_inode = NULL,	.delete_inode = NULL,	.read_super = read_super_rf,	.write_super = NULL,};static fs_type_t rootfs_type = {	.name = "rootfs",	.fs_flag = 0,	.mount = rootfs_mount,	.kill_sb = rootfs_kill_sb};static inode_operations rootfs_inode_op = {	.create = create_rf,	.lookup = lookup_rf,	.link = NULL,	.unlink = NULL,	.symlink = NULL,	.mkdir = mkdir_rf,	.rmdir = rmdir_rf,	.mknod = NULL,	.rename = rename_rf,	.readlink = NULL,	.truncate = NULL,	.permission = NULL,	.setattr = NULL,	.getattr = NULL,	.setxattr = NULL,	.getxattr = NULL,	.listxattr = NULL,	.removexattr = NULL};static struct dentry_operations rootfs_dentry_op = {	.d_revalidate = NULL,	.d_hash = NULL,	.d_compare = NULL,	.d_delete = NULL,	.d_release = NULL,	.d_iput = NULL};static struct file_operations rootfs_file_op = {	.read = rfs_read,	.write = rfs_write,	.ioctl = rfs_ioctl,	.open = rfs_open,	.close = rfs_close,	.lseek = rfs_seek,	.mmap = rfs_mmap	.flush = NULL,	.release = NULL,	.fsync = NULL,	.fasync = NULL,	.check_flags = NULL,};static vfsmount_t rootfs_vfsmnt = {0};/*super block的初始化函数，对rootfs来说，就是申请内存，赋初值*/int read_super_rf(sb_t * pSblk){	if(NULL == pSblk)	{		return KER_FAIL;	}	pSblk->s_dev = 0;	pSblk->s_blocksize_bits = 8;	pSblk->s_blocksize = 4096;	pSblk->s_files = NULL;	pSblk->s_inodes = NULL;	pSblk->s_magic = ROOTFS_MAGIC_NUM;	pSblk->s_root = NULL;	pSblk->s_op = &rootfs_op;	return KER_SUC;}/*super block的操作函数，用于初始化一个inode对象*/inode_t * alloc_inode_rf(sb_t * psb){	inode_t * new_inode = (inode_t*)kmalloc(sizeof(inode_t));	if(NULL == new_inode)	{		return NULL;	}	memset(new_inode,0,sizeof(inode_t));	new_inode->i_ctime = time(0);	new_inode->i_blkbits = psb->s_blocksize_bits;	new_inode->i_blocks = psb->s_blocksize;		new_inode->i_ino = 0xFFFFFFFF;	new_inode->i_count = 0;	new_inode->i_op = &rootfs_inode_op;	new_inode->i_fop = &rootfs_file_op;	new_inode->i_mapping = NULL;		push_ring_list(&(psb->s_inodes),&(new_inode->i_list));	return new_inode;}/*super block用于释放inode的函数*/void destroy_inode_rf(inode_t * pinode){	if(NULL != pinode)	{		if(pinode->i_private)		{			kfree(pinode->i_private);		}		kfree(pinode);	}}inode_t* create_rf(inode_t * dir, dentry_t * pDentry, int mode){	inode_t * pinode = pDentry->d_sb->s_op->alloc_inode(pDentry->d_sb);	pinode->i_count = 1;	pinode->i_dirty = 1;	pinode->i_uid = current->uid;	pinode->i_gid = current->gid;	pinode->i_size = 0;	pinode->i_mode = mode;	pinode->i_private = NULL;	pDentry->d_inode = pinode;	return NULL;}//创建目录。 1，创建inode。2，创建dentry，3，创建file。4，加入链表。//输入：pnode：父目录inode。pDentry：本目录。mode：读写权限。int mkdir_rf(inode_t * pNode, dentry_t * pDentry, mode_t mode ){	struct list_head * tmp = NULL;	sb_t * s = pDentry->d_sb;	inode_t * new_node = alloc_inode_rf(s);	if(NULL == new_node)	{		return -1;	}	pDentry->d_inode = new_node;	return 0;}int rmdir_rf(inode_t * pinode, dentry_t * pdentry){	inode_t * fnode = pdentry->d_parent->d_inode;	inode_t * fdentry = pdentry->d_parent;	sb_t * s = pdentry->d_sb;	pinode->i_list.next->prev = pinode->i_list.prev;	pinode->i_list.prev->next = pinode->i_list.next;	s->s_op->delete_inode(pinode);	pdentry->d_child.next->prev = pdentry->d_child.prev;	pdentry->d_child.prev->next = pdentry->d_child.next;	pdentry->d_op->d_delete(pdentry);}int rename_rf(inode_t * pinode, dentry_t * pdentry){	//rootfs中文件名保存在dentry，无需修改inode；	return 0;}/* 输入：1，dir 在此目录下进行查找。		2，pdentry 查找的目标索引对应于pedantry   输出：目标索引对应的dentry。   对于rootfs来说，所有的inode和dentry都在内存中，当找到了dentry，自然也就找到了inode。*/dentry_t * lookup_rf(inode_t * dir, dentry_t * pdentry){	return pdentry->d_inode;}dentry_t * create_dentry_rf(char * name, u32 flag){	dentry_t * pDentry = kmalloc(sizeof(dentry_t));	if(NULL == pDentry)	{		logging("[FATAL]:kmalloc dentry is failed!\r\n");		return NULL;	}	strncpy(pDentry->d_iname, name, DNAME_LEN_MAX);	pDentry->d_flags = flag;	return pDentry;}//从文件file偏移量offset处，读取count字节的数据到buf中int rfs_read(file_t * pfile, char * buf, int count, int offset){	pfile->f_dentry->d_inode->i_private	return 0;}//被系统调用write调用，从buf中读取数据，以file的offset为起始位置，写count字节数据int rfs_write(file_t * pfile, char * buf, int count, int offset){	return 0;}/*被系统调用ioctl调用，将一个命令和一系列参数发送给一个设备。当file是一个打开的设备节点时会使用此函数，调用者必须持有BKL(Big Kernel Lock)*/int rfs_ioctl(inode_t * pinode, file_t * pfile, u32 cmd, ulong arg){	return 0;}int rfs_open(){	return 0;}int rfs_close(){	return 0;}int rfs_seek(){	return 0;}int rfs_mmap(){	return 0;}dentry_t * lookup_dentry(char * name){	dentry_t * d_tmp = g_dentry;	queue_t * d_queue = create_queue();	while(d_tmp)	{		if(0 == strcmp(d_tmp->d_iname, name))		{			return d_tmp;		}		dentry_t * subdir = (dentry_t *)(d_tmp->d_subdirs.next);		if(NULL != subdir)		{			lnode_t * tmp_node1 = kmalloc(sizeof(lnode_t));			tmp_node1->pNode = (void *)subdir;			push(d_queue, tmp_node1);		}		dentry_t * child = (dentry_t *)(d_tmp->d_child.next - 1);		if(NULL != subdir)		{			lnode_t * tmp_node2 = kmalloc(sizeof(lnode_t));			tmp_node2->pNode = (void *)child;			push(d_queue, tmp_node2);		}		d_tmp = (dentry_t *)pop(d_queue);	}	free(d_queue);}file_t * create_file(char * father, char * name, u32 flag){	file_t * f_new = kmalloc(sizeof(file_t));	if(NULL == f_new)	{		logging("[FATAL]kmalloc file is failed!\r\n");		return NULL;	}	dentry_t * d_new = create_dentry_rf(name, flag);	if(NULL == d_new)	{		kfree(f_new);		logging("[FATAL]kmalloc dentry is failed!\r\n");		return NULL;	}	f_new->f_count = 1;	f_new->f_op = &rootfs_file_op;	f_new->f_dentry = d_new;	f_new->f_dirty = 0;	f_new->f_mode = 0x777;	f_new->f_pos = 0;	f_new->f_private = NULL;		if(g_dentry->d_subdirs.next)	{		dentry_t * son = (dentry_t *)(g_dentry->d_subdirs->next);		struct list_head * child_tail = getlast_lh(&(son->d_child)); 		child_tail->next = &(d_new->d_child);		d_new->d_child.prev = child_tail;	}	else	{		g_dentry->d_subdirs.next = d_new->d_subdirs;		d_new->d_subdirs.prev = g_dentry->d_subdirs;	}	return f_new;}dentry_t * rootfs_mount(struct file_system_type * fs_type, int flags, const char * fs_name, void * data){	dentry_t * new_dentry = (dentry_t *)kmalloc(sizeof(dentry_t));	if(NULL == new_dentry)	{		logging("[FATAL] kmalloc rootfs new dentry failed!\r\n");		return NULL;	}	memset(new_dentry,0,sizeof(dentry_t));	int name_len = strlen(fs_name);	strncpy(new_dentry->d_iname,fs_name, DNAME_LEN_MAX>name_len?name_len:(DNAME_LEN_MAX-1));	sb_t * psb = sget(fs_type);	inode_t *root_node = alloc_inode_rf(psb);	if(NULL == root_node)	{		return NULL;	}	new_dentry->d_inode = root_node;	new_dentry->d_mounted = ;	new_dentry->d_flags = flags;	new_dentry->d_parent = NULL;	new_dentry->d_op = &rootfs_dentry_op;	new_dentry->d_sb = psb;	new_dentry->d_time = time(0);	new_dentry->d_fsdata = data;	return new_dentry;}void * rootfs_kill_sb(sb_t * psblk){	if(list_head_del_node(psblk->s_list))	{		file_t * delfile = (inode_t *)(psblk->s_files);		while(delfile)		{			psblk->s_files = delfile->f_list->next;			free(delfile);		}		inode_t * delnode = (inode_t *)(psblk->s_inodes);		while(delnode)		{			psblk->s_inodes = delnode->i_list->next;			psblk->s_op->destroy_inode(delnode));			delnode = (inode_t *)(psblk->s_inodes);		}		kfree(psblk);	};}void init_rootfs(){	register_filesystem(&rootfs_type);	g_vfsmount = (vfsmount_t *)kmalloc(sizeof(vfsmount_t));	if(NULL == g_vfsmount)	{		logging("[ERROR] kmalloc vfsmount for g_vfsmount is failed!");		return;	}	g_vfsmount->m_parent = NULL;	g_vfsmount->m_root = (dentry_t *)kmalloc(sizeof(dentry_t));	memset(g_vfsmount->m_root,0,sizeof(dentry_t));	g_vfsmount->m_mntpoint = NULL;	init_line_list_head(&(g_vfsmount->m_mount));	init_line_list_head(&(g_vfsmount->m_child));	g_sblk = (sb_t *)kmalloc(sizeof(sb_t));	memset(g_sblk,0,sizeof(sb_t));	g_sblk->s_type = &rootfs_type;	g_sblk->s_dev = 0;	g_sblk->s_op = &rootfs_op;	g_sblk->s_flags = 0;	g_sblk->s_magic = 0;	g_sblk->s_root = g_vfsmount->m_root;	g_sblk->s_umount = 0;	g_sblk->s_count = 1;	g_sblk->s_active = 1;	g_sblk->s_fs_info = NULL;	g_sblk->s_blocksize_bits = 8;	g_sblk->s_blocksize = 1;	g_sblk->s_maxbytes = 10;	init_ring_list_head(&(g_sblk->s_inodes));	g_vfsmount->m_sb = g_sblk;	init_line_list_head(&(g_vfsmount->m_root->d_subdirs));	init_line_list_head(&(g_vfsmount->m_root->d_child));	inode_t * root = g_sblk->s_op->alloc_inode(g_sblk);	g_vfsmount->m_root->d_inode = root;	sprintf(g_vfsmount->m_root->d_iname,"/");	g_vfsmount->m_root->d_mounted = 0;	g_vfsmount->m_root->d_flags = DENTRY_FLAG_RO;	g_vfsmount->m_root->d_parent = NULL;	g_vfsmount->m_root->d_op = &rootfs_dentry_op;	g_vfsmount->m_root->d_sb = g_sblk;	g_vfsmount->m_root->d_time = time(0);	g_vfsmount->m_root->d_fsdata = NULL;		logging("[INFO] init rootfs success!\r\n");	return;}/*创建根目录以及几个基本的目录项*/void init_mnt_tree(){	file_t * f_boot = create_file("boot"， 0);	inode_t * i_boot = alloc_inode_rf(g_sblk);	dentry_t * d_boot = f_boot->f_dentry;	struct list_head * inode_tail = getlast_lh(&(g_sblk->s_inodes));	inode_tail->next = &(i_boot->i_list);	i_boot->i_list->prev = inode_tail;		d_boot->d_inode = i_boot;}